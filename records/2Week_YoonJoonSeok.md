## Title: [2Week] 윤준석

### 미션 요구사항 분석 & 체크리스트

---
- 한명의 인스타회원이 다른 인스타회원에게 중복으로 호감표시를 할 수 없어야 한다
- 한명의 인스타회원이 11명 이상의 호감상대를 등록 할 수 없어야 한다
- 중복으로 호감을 표시할 때 기존의 사유와 다른 사유로 호감을 표시하는 경우 기존 호감표시에서 사유만 수정한다


- 카카오, 구글 로그인이 가능한것 처럼, 네이버 로그인으로도 가입 및 로그인 처리가 되어야 한다


- [x] 호감 등록 시 중복 불가
    - [x] 테스트 케이스
    - [x] 조건에 걸릴 시 rq.historyBack
- [x] 한명이 11명 이상 호감 등록 불가
    - [x] 테스트 케이스
    - [x] 조건에 걸릴 시 rq.historyBack
- [x] 기존의 호감 사유 수정 가능
    - [x] 테스트 케이스


- [x] 네이버 로그인 기능

### 2주차 미션 요약

---

**[접근 방법]**

기능을 구현하기 위해 다음과 같이 접근을 하였다
- 호감 등록 시 사용자의 instaMember 정보를 가져와 getFromLikeablePeople 함수를 통해 사용자와 관련된 모든 호감 정보를 가져와 비교를 하면 중복을 찾아낼 수 있을 것이다
- 이미 가져온 사용자의 모든 호감정보 리스트의 size 함수를 쓰면 등록된 호감 수를 알 수 있을 것이다
- 호감 상대 수정의 경우, 호감 상대가 중복을 찾는 과정에서 attractiveTypeCode를 추가해서 비교하면 될 것이다


- 이미 OAuth2 관련 기능은 구현되어 있기 때문에 네이버 로그인을 구현하려면 카카오, 구글 로그인 구현처럼 앱을 등록한 후 앱키를 받아 application(-secret).yml에 관련 정보를 넣으면 될 것이다

처음엔 어짜피 등록된 호감 개수를 알아야 하므로 아예 사용자의 instamember 정보를 통채로 가져오는 것이 좋을 것 같아 자바 코드를 통해 직접 중복 확인과 개수 확인을 하였다.
정상적으로 작동은 했지만 코드가 너무 길어지고 자원 낭비와 더불어 불필요한 쿼리가 발생될 수도 있다는 생각이 들었다. 그래서 Spring Data JPA에서 제공하는 기능을 전면 활용해 정말 필요한 정보만 가져오게 코드를 수정하였다. 쿼리가 줄어들긴 줄었는데 13개에서 12로 고작 1개만 줄어들어 드라마틱한 성능 발전은 없었다.
더 좋은 코드는 무엇일까 고민을 해봐야 할 것 같다.

OAuth2.0 방식으로 네이버 로그인을 구현하기 위해 블로그를 참고하였다.(https://loosie.tistory.com/301)
카카오, 구글 로그인 구현과 비슷한 방식으로 네이버 Developers에 앱 등록을 한 뒤 앱키를 받았고, application-secret.yml에서 3줄만 필요했던 구글과 달리 카카오처럼 registration 항목에 client-id, client-secret, redirect-uri, authorization-grant-type, scope, client-name, 
provider 항목에 authorization_uri, token_uri, user-info-uri, user_name_attribute 값을 추가하였다. (github상으로는 볼 수 없다) 그런데 블로그를 그대로 따라했더니 오류가 생기면서 기능이 작동하지 않았다. 그 이유는 application-secret.yml의 redirect-uri와 앱을 등록하면서 입력한 redirect-uri가 달랐기 때문이었다. redirect-uri를 통일시켰더니 정상적으로 작동함을 확인할 수 있었다. 그런데 네이버 API를 통해 받아온 id 값엔 카카오, 구글과 달리 scope에서 설정한 값들이 같이 들어감을 확인할 수 있었다. 그래서 CustomOAuth2UserService에서 providerTypeCode의 코드가 "NAVER"인 경우 id만 추출하게 하는 코드를 추가로 작성해주었다.


**[특이사항]**

- 호감을 등록하기 전 예외 처리의 코드가 너무 긴 것 같아 어느정도 분리를 해주는게 좋을 것 같은데 어떻게 분리할 지 고민해봐야 할 것 같다


- 호감을 등록하기 전 예외 처리 과정에서 쿼리 발생을 더 줄일 수 있는 방법을 고민해봐야 할 것 같다